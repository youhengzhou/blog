---
title: "Understanding Recursion and the Limits of Intelligence"
date: "2023-09-10"
# weight: 1
# aliases: ["/first"]
# tags: ["technology"]
author: "Written by Yohannes Zhou"
# author: ["Me", "You"] # multiple authors
showToc: false
TocOpen: false
draft: false
hidemeta: false
comments: false
description: ""
# canonicalURL: ""
disableHLJS: true # to disable highlightjs
disableShare: false
disableHLJS: false
hideSummary: false
searchHidden: true
ShowReadingTime: false
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowWordCount: false
ShowRssButtonInSectionTermList: true
UseHugoToc: false
# cover:
#     image: "<image path/url>" # image path/url
#     alt: "<alt text>" # alt text
#     caption: "<text>" # display caption under cover
#     relative: false # when using page bundles set this to true
#     hidden: true # only hide on current single page
# editPost:
#     URL: "https://github.com/<path_to_repo>/content"
#     Text: "Suggest Changes" # edit text
#     appendFilePath: true # to append file path to Edit link
---

![img](/blog/images/01/sunset.jpg#center)

## Part 1. Introduction

Recursion is a common pattern in programming. It occurs on many algorithm problems mostly relating to trees and graphs.

Recursion also seems to be one of those algorithms in programming where people either “get it” or “don’t get it.” Some people with experience would find it trivial, but it would seem almost impossible for beginner programmers or the layperson who had no prior experience with programming.

By comparison, problems involving arrays, hashmaps are much more intuitive for the layperson, even though arguably they present the same amount of difficulty in hindsight.

And before I start to really explain Recursion, which was the goal of me writing this article, I want to also point out as motivation for you, that most concepts in programming, computer science, and possibly every field such as physics and medicine are not necessarily hard on their own.

These hard concepts once grasped will not be difficult in hindsight, and people who seem to be very efficient in using these concepts and can present themselves as masters of these intellectual crafts are not much smarter than you on a genetic level.

As Fitzpatrick said in The Programmer’s Brain, the human brain can only keep track of 2 to 6 items at a time.[1] This means if our brains were computers, a chess grandmaster, competitive coder, or nuclear physicist fundamentally operate on approximately the same specs of computers, bar the problems with motivation and conscientiousness, we should all be able to perform around the same in intellectual tasks.

![img](/blog/images/01/stmvsltm.png#center)

So what makes the difference?

In short, it’s because of heuristics that experienced programmers use. Heuristics that operate as abstractions and assumptions that can break a complicated problem with oftentimes more than 6 moving parts into something with less than 6 moving parts for the programmer’s limited “brain ram” to handle.

And I want to present to you several heuristics that I personally use to solve and remove complexity from problems.

## Part 2. Drilling Steps

coming soon...

## Citations

Fitzpatrick, Felienne. (2021). The Programmer’s Brain. Manning Publications. “As you saw in chapter 2, the STM can typically only hold two to six items at a time.” (p. 49).
